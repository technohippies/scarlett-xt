var background=function(){"use strict";var br=Object.defineProperty;var yr=(D,F,U)=>F in D?br(D,F,{enumerable:!0,configurable:!0,writable:!0,value:U}):D[F]=U;var Ee=(D,F,U)=>yr(D,typeof F!="symbol"?F+"":F,U);var ve,ke;function D(e){return e==null||typeof e=="function"?{main:e}:e}function F(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var U={exports:{}},Se=U.exports,ce;function Ce(){return ce||(ce=1,function(e,r){(function(t,n){n(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:Se,function(t){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)t.exports=globalThis.browser;else{const n="The message port closed before a response was received.",s=o=>{const l={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(l).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class m extends WeakMap{constructor(d,a=void 0){super(a),this.createItem=d}get(d){return this.has(d)||this.set(d,this.createItem(d)),super.get(d)}}const g=u=>u&&typeof u=="object"&&typeof u.then=="function",c=(u,d)=>(...a)=>{o.runtime.lastError?u.reject(new Error(o.runtime.lastError.message)):d.singleCallbackArg||a.length<=1&&d.singleCallbackArg!==!1?u.resolve(a[0]):u.resolve(a)},f=u=>u==1?"argument":"arguments",y=(u,d)=>function(i,...h){if(h.length<d.minArgs)throw new Error(`Expected at least ${d.minArgs} ${f(d.minArgs)} for ${u}(), got ${h.length}`);if(h.length>d.maxArgs)throw new Error(`Expected at most ${d.maxArgs} ${f(d.maxArgs)} for ${u}(), got ${h.length}`);return new Promise((x,k)=>{if(d.fallbackToNoCallback)try{i[u](...h,c({resolve:x,reject:k},d))}catch(p){console.warn(`${u} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,p),i[u](...h),d.fallbackToNoCallback=!1,d.noCallback=!0,x()}else d.noCallback?(i[u](...h),x()):i[u](...h,c({resolve:x,reject:k},d))})},w=(u,d,a)=>new Proxy(d,{apply(i,h,x){return a.call(h,u,...x)}});let T=Function.call.bind(Object.prototype.hasOwnProperty);const v=(u,d={},a={})=>{let i=Object.create(null),h={has(k,p){return p in u||p in i},get(k,p,C){if(p in i)return i[p];if(!(p in u))return;let A=u[p];if(typeof A=="function")if(typeof d[p]=="function")A=w(u,u[p],d[p]);else if(T(a,p)){let P=y(p,a[p]);A=w(u,u[p],P)}else A=A.bind(u);else if(typeof A=="object"&&A!==null&&(T(d,p)||T(a,p)))A=v(A,d[p],a[p]);else if(T(a,"*"))A=v(A,d[p],a["*"]);else return Object.defineProperty(i,p,{configurable:!0,enumerable:!0,get(){return u[p]},set(P){u[p]=P}}),A;return i[p]=A,A},set(k,p,C,A){return p in i?i[p]=C:u[p]=C,!0},defineProperty(k,p,C){return Reflect.defineProperty(i,p,C)},deleteProperty(k,p){return Reflect.deleteProperty(i,p)}},x=Object.create(u);return new Proxy(x,h)},b=u=>({addListener(d,a,...i){d.addListener(u.get(a),...i)},hasListener(d,a){return d.hasListener(u.get(a))},removeListener(d,a){d.removeListener(u.get(a))}}),E=new m(u=>typeof u!="function"?u:function(a){const i=v(a,{},{getContent:{minArgs:0,maxArgs:0}});u(i)}),S=new m(u=>typeof u!="function"?u:function(a,i,h){let x=!1,k,p=new Promise(_=>{k=function(R){x=!0,_(R)}}),C;try{C=u(a,i,k)}catch(_){C=Promise.reject(_)}const A=C!==!0&&g(C);if(C!==!0&&!A&&!x)return!1;const P=_=>{_.then(R=>{h(R)},R=>{let j;R&&(R instanceof Error||typeof R.message=="string")?j=R.message:j="An unexpected error occurred",h({__mozWebExtensionPolyfillReject__:!0,message:j})}).catch(R=>{console.error("Failed to send onMessage rejected reply",R)})};return P(A?C:p),!0}),$=({reject:u,resolve:d},a)=>{o.runtime.lastError?o.runtime.lastError.message===n?d():u(new Error(o.runtime.lastError.message)):a&&a.__mozWebExtensionPolyfillReject__?u(new Error(a.message)):d(a)},N=(u,d,a,...i)=>{if(i.length<d.minArgs)throw new Error(`Expected at least ${d.minArgs} ${f(d.minArgs)} for ${u}(), got ${i.length}`);if(i.length>d.maxArgs)throw new Error(`Expected at most ${d.maxArgs} ${f(d.maxArgs)} for ${u}(), got ${i.length}`);return new Promise((h,x)=>{const k=$.bind(null,{resolve:h,reject:x});i.push(k),a.sendMessage(...i)})},J={devtools:{network:{onRequestFinished:b(E)}},runtime:{onMessage:b(S),onMessageExternal:b(S),sendMessage:N.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:N.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},I={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return l.privacy={network:{"*":I},services:{"*":I},websites:{"*":I}},v(o,J,l)};t.exports=s(chrome)}})}(U)),U.exports}var _e=Ce();const O=F(_e),Te=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,globalThis.DOMException,globalThis.AssertionError,globalThis.SystemError].filter(Boolean).map(e=>[e.name,e]),$e=new Map(Te);class K extends Error{constructor(t){super(K._prepareSuperMessage(t));Ee(this,"name","NonError")}static _prepareSuperMessage(t){try{return JSON.stringify(t)}catch{return String(t)}}}const Oe=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0},{property:"cause",enumerable:!1}],Q=new WeakSet,Pe=e=>{Q.add(e);const r=e.toJSON();return Q.delete(e),r},ge=e=>$e.get(e)??Error,X=({from:e,seen:r,to:t,forceEnumerable:n,maxDepth:s,depth:o,useToJSON:l,serialize:m})=>{if(!t)if(Array.isArray(e))t=[];else if(!m&&me(e)){const c=ge(e.name);t=new c}else t={};if(r.push(e),o>=s)return t;if(l&&typeof e.toJSON=="function"&&!Q.has(e))return Pe(e);const g=c=>X({from:c,seen:[...r],forceEnumerable:n,maxDepth:s,depth:o,useToJSON:l,serialize:m});for(const[c,f]of Object.entries(e)){if(f&&f instanceof Uint8Array&&f.constructor.name==="Buffer"){t[c]="[object Buffer]";continue}if(f!==null&&typeof f=="object"&&typeof f.pipe=="function"){t[c]="[object Stream]";continue}if(typeof f!="function"){if(!f||typeof f!="object"){try{t[c]=f}catch{}continue}if(!r.includes(e[c])){o++,t[c]=g(e[c]);continue}t[c]="[Circular]"}}for(const{property:c,enumerable:f}of Oe)typeof e[c]<"u"&&e[c]!==null&&Object.defineProperty(t,c,{value:me(e[c])?g(e[c]):e[c],enumerable:n?!0:f,configurable:!0,writable:!0});return t};function Re(e,r={}){const{maxDepth:t=Number.POSITIVE_INFINITY,useToJSON:n=!0}=r;return typeof e=="object"&&e!==null?X({from:e,seen:[],forceEnumerable:!0,maxDepth:t,depth:0,useToJSON:n,serialize:!0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}function Be(e,r={}){const{maxDepth:t=Number.POSITIVE_INFINITY}=r;if(e instanceof Error)return e;if(Ne(e)){const n=ge(e.name);return X({from:e,seen:[],to:new n,maxDepth:t,depth:0,serialize:!1})}return new K(e)}function me(e){return!!e&&typeof e=="object"&&"name"in e&&"message"in e&&"stack"in e}function Ne(e){return!!e&&typeof e=="object"&&"message"in e&&!Array.isArray(e)}var Me=Object.defineProperty,Fe=Object.defineProperties,Ie=Object.getOwnPropertyDescriptors,ue=Object.getOwnPropertySymbols,Le=Object.prototype.hasOwnProperty,Ue=Object.prototype.propertyIsEnumerable,de=(e,r,t)=>r in e?Me(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,Ae=(e,r)=>{for(var t in r||(r={}))Le.call(r,t)&&de(e,t,r[t]);if(ue)for(var t of ue(r))Ue.call(r,t)&&de(e,t,r[t]);return e},fe=(e,r)=>Fe(e,Ie(r)),je=(e,r,t)=>new Promise((n,s)=>{var o=g=>{try{m(t.next(g))}catch(c){s(c)}},l=g=>{try{m(t.throw(g))}catch(c){s(c)}},m=g=>g.done?n(g.value):Promise.resolve(g.value).then(o,l);m((t=t.apply(e,r)).next())});function qe(e){let r,t={};function n(){Object.entries(t).length===0&&(r==null||r(),r=void 0)}let s=Math.floor(Math.random()*1e4);function o(){return s++}return{sendMessage(l,m,...g){return je(this,null,function*(){var c,f,y,w;const T={id:o(),type:l,data:m,timestamp:Date.now()},v=(f=yield(c=e.verifyMessageData)==null?void 0:c.call(e,T))!=null?f:T;(y=e.logger)==null||y.debug(`[messaging] sendMessage {id=${v.id}} ─ᐅ`,v,...g);const b=yield e.sendMessage(v,...g),{res:E,err:S}=b??{err:new Error("No response")};if((w=e.logger)==null||w.debug(`[messaging] sendMessage {id=${v.id}} ᐊ─`,{res:E,err:S}),S!=null)throw Be(S);return E})},onMessage(l,m){var g,c,f;if(r==null&&((g=e.logger)==null||g.debug(`[messaging] "${l}" initialized the message listener for this context`),r=e.addRootListener(y=>{var w,T;if(typeof y.type!="string"||typeof y.timestamp!="number"){if(e.breakError)return;const E=Error(`[messaging] Unknown message format, must include the 'type' & 'timestamp' fields, received: ${JSON.stringify(y)}`);throw(w=e.logger)==null||w.error(E),E}(T=e==null?void 0:e.logger)==null||T.debug("[messaging] Received message",y);const v=t[y.type];if(v==null)return;const b=v(y);return Promise.resolve(b).then(E=>{var S,$;return($=(S=e.verifyMessageData)==null?void 0:S.call(e,E))!=null?$:E}).then(E=>{var S;return(S=e==null?void 0:e.logger)==null||S.debug(`[messaging] onMessage {id=${y.id}} ─ᐅ`,{res:E}),{res:E}}).catch(E=>{var S;return(S=e==null?void 0:e.logger)==null||S.debug(`[messaging] onMessage {id=${y.id}} ─ᐅ`,{err:E}),{err:Re(E)}})})),t[l]!=null){const y=Error(`[messaging] In this JS context, only one listener can be setup for ${l}`);throw(c=e.logger)==null||c.error(y),y}return t[l]=m,(f=e.logger)==null||f.log(`[messaging] Added listener for ${l}`),()=>{delete t[l],n()}},removeAllListeners(){Object.keys(t).forEach(l=>{delete t[l]}),n()}}}var V={exports:{}},De=V.exports,he;function We(){return he||(he=1,function(e,r){(function(t,n){n(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:De,function(t){var n,s;if(!((s=(n=globalThis.chrome)==null?void 0:n.runtime)!=null&&s.id))throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const o="The message port closed before a response was received.",l=m=>{const g={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(g).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class c extends WeakMap{constructor(i,h=void 0){super(h),this.createItem=i}get(i){return this.has(i)||this.set(i,this.createItem(i)),super.get(i)}}const f=a=>a&&typeof a=="object"&&typeof a.then=="function",y=(a,i)=>(...h)=>{m.runtime.lastError?a.reject(new Error(m.runtime.lastError.message)):i.singleCallbackArg||h.length<=1&&i.singleCallbackArg!==!1?a.resolve(h[0]):a.resolve(h)},w=a=>a==1?"argument":"arguments",T=(a,i)=>function(x,...k){if(k.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${w(i.minArgs)} for ${a}(), got ${k.length}`);if(k.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${w(i.maxArgs)} for ${a}(), got ${k.length}`);return new Promise((p,C)=>{if(i.fallbackToNoCallback)try{x[a](...k,y({resolve:p,reject:C},i))}catch(A){console.warn(`${a} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,A),x[a](...k),i.fallbackToNoCallback=!1,i.noCallback=!0,p()}else i.noCallback?(x[a](...k),p()):x[a](...k,y({resolve:p,reject:C},i))})},v=(a,i,h)=>new Proxy(i,{apply(x,k,p){return h.call(k,a,...p)}});let b=Function.call.bind(Object.prototype.hasOwnProperty);const E=(a,i={},h={})=>{let x=Object.create(null),k={has(C,A){return A in a||A in x},get(C,A,P){if(A in x)return x[A];if(!(A in a))return;let _=a[A];if(typeof _=="function")if(typeof i[A]=="function")_=v(a,a[A],i[A]);else if(b(h,A)){let R=T(A,h[A]);_=v(a,a[A],R)}else _=_.bind(a);else if(typeof _=="object"&&_!==null&&(b(i,A)||b(h,A)))_=E(_,i[A],h[A]);else if(b(h,"*"))_=E(_,i[A],h["*"]);else return Object.defineProperty(x,A,{configurable:!0,enumerable:!0,get(){return a[A]},set(R){a[A]=R}}),_;return x[A]=_,_},set(C,A,P,_){return A in x?x[A]=P:a[A]=P,!0},defineProperty(C,A,P){return Reflect.defineProperty(x,A,P)},deleteProperty(C,A){return Reflect.deleteProperty(x,A)}},p=Object.create(a);return new Proxy(p,k)},S=a=>({addListener(i,h,...x){i.addListener(a.get(h),...x)},hasListener(i,h){return i.hasListener(a.get(h))},removeListener(i,h){i.removeListener(a.get(h))}}),$=new c(a=>typeof a!="function"?a:function(h){const x=E(h,{},{getContent:{minArgs:0,maxArgs:0}});a(x)}),N=new c(a=>typeof a!="function"?a:function(h,x,k){let p=!1,C,A=new Promise(j=>{C=function(L){p=!0,j(L)}}),P;try{P=a(h,x,C)}catch(j){P=Promise.reject(j)}const _=P!==!0&&f(P);if(P!==!0&&!_&&!p)return!1;const R=j=>{j.then(L=>{k(L)},L=>{let le;L&&(L instanceof Error||typeof L.message=="string")?le=L.message:le="An unexpected error occurred",k({__mozWebExtensionPolyfillReject__:!0,message:le})}).catch(L=>{console.error("Failed to send onMessage rejected reply",L)})};return R(_?P:A),!0}),J=({reject:a,resolve:i},h)=>{m.runtime.lastError?m.runtime.lastError.message===o?i():a(new Error(m.runtime.lastError.message)):h&&h.__mozWebExtensionPolyfillReject__?a(new Error(h.message)):i(h)},I=(a,i,h,...x)=>{if(x.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${w(i.minArgs)} for ${a}(), got ${x.length}`);if(x.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${w(i.maxArgs)} for ${a}(), got ${x.length}`);return new Promise((k,p)=>{const C=J.bind(null,{resolve:k,reject:p});x.push(C),h.sendMessage(...x)})},u={devtools:{network:{onRequestFinished:S($)}},runtime:{onMessage:S(N),onMessageExternal:S(N),sendMessage:I.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:I.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},d={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return g.privacy={network:{"*":d},services:{"*":d},websites:{"*":d}},E(m,u,g)};t.exports=l(chrome)}else t.exports=globalThis.browser})}(V)),V.exports}var Je=We();const H=F(Je);function ze(e){return qe(fe(Ae({},e),{sendMessage(r,t){if(t==null)return H.runtime.sendMessage(r);const n=typeof t=="number"?{tabId:t}:t;return H.tabs.sendMessage(n.tabId,r,n.frameId!=null?{frameId:n.frameId}:void 0)},addRootListener(r){const t=(n,s)=>r(typeof n=="object"?fe(Ae({},n),{sender:s}):n);return H.runtime.onMessage.addListener(t),()=>H.runtime.onMessage.removeListener(t)}}))}const pe=ze(),q=pe.onMessage,M=pe.sendMessage,Ge=new Error("request for lock canceled");var Ve=function(e,r,t,n){function s(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function m(f){try{c(n.next(f))}catch(y){l(y)}}function g(f){try{c(n.throw(f))}catch(y){l(y)}}function c(f){f.done?o(f.value):s(f.value).then(m,g)}c((n=n.apply(e,r||[])).next())})};class He{constructor(r,t=Ge){this._value=r,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(r=1,t=0){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);return new Promise((n,s)=>{const o={resolve:n,reject:s,weight:r,priority:t},l=xe(this._queue,m=>t<=m.priority);l===-1&&r<=this._value?this._dispatchItem(o):this._queue.splice(l+1,0,o)})}runExclusive(r){return Ve(this,arguments,void 0,function*(t,n=1,s=0){const[o,l]=yield this.acquire(n,s);try{return yield t(o)}finally{l()}})}waitForUnlock(r=1,t=0){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);return this._couldLockImmediately(r,t)?Promise.resolve():new Promise(n=>{this._weightedWaiters[r-1]||(this._weightedWaiters[r-1]=[]),Ze(this._weightedWaiters[r-1],{resolve:n,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(r){this._value=r,this._dispatchQueue()}release(r=1){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);this._value+=r,this._dispatchQueue()}cancel(){this._queue.forEach(r=>r.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(r){const t=this._value;this._value-=r.weight,r.resolve([t,this._newReleaser(r.weight)])}_newReleaser(r){let t=!1;return()=>{t||(t=!0,this.release(r))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let r=this._value;r>0;r--){const t=this._weightedWaiters[r-1];t&&(t.forEach(n=>n.resolve()),this._weightedWaiters[r-1]=[])}else{const r=this._queue[0].priority;for(let t=this._value;t>0;t--){const n=this._weightedWaiters[t-1];if(!n)continue;const s=n.findIndex(o=>o.priority<=r);(s===-1?n:n.splice(0,s)).forEach(o=>o.resolve())}}}_couldLockImmediately(r,t){return(this._queue.length===0||this._queue[0].priority<t)&&r<=this._value}}function Ze(e,r){const t=xe(e,n=>r.priority<=n.priority);e.splice(t+1,0,r)}function xe(e,r){for(let t=e.length-1;t>=0;t--)if(r(e[t]))return t;return-1}var Ye=function(e,r,t,n){function s(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function m(f){try{c(n.next(f))}catch(y){l(y)}}function g(f){try{c(n.throw(f))}catch(y){l(y)}}function c(f){f.done?o(f.value):s(f.value).then(m,g)}c((n=n.apply(e,r||[])).next())})};class Ke{constructor(r){this._semaphore=new He(1,r)}acquire(){return Ye(this,arguments,void 0,function*(r=0){const[,t]=yield this._semaphore.acquire(1,r);return t})}runExclusive(r,t=0){return this._semaphore.runExclusive(()=>r(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(r=0){return this._semaphore.waitForUnlock(1,r)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}var Z=(e=>(e[e.New=0]="New",e[e.Learning=1]="Learning",e[e.Review=2]="Review",e[e.Relearning=3]="Relearning",e))(Z||{}),W=(e=>(e[e.Manual=0]="Manual",e[e.Again=1]="Again",e[e.Hard=2]="Hard",e[e.Good=3]="Good",e[e.Easy=4]="Easy",e))(W||{});class B{static card(r){return{...r,state:B.state(r.state),due:B.time(r.due),last_review:r.last_review?B.time(r.last_review):void 0}}static rating(r){if(typeof r=="string"){const t=r.charAt(0).toUpperCase(),n=r.slice(1).toLowerCase(),s=W[`${t}${n}`];if(s===void 0)throw new Error(`Invalid rating:[${r}]`);return s}else if(typeof r=="number")return r;throw new Error(`Invalid rating:[${r}]`)}static state(r){if(typeof r=="string"){const t=r.charAt(0).toUpperCase(),n=r.slice(1).toLowerCase(),s=Z[`${t}${n}`];if(s===void 0)throw new Error(`Invalid state:[${r}]`);return s}else if(typeof r=="number")return r;throw new Error(`Invalid state:[${r}]`)}static time(r){if(typeof r=="object"&&r instanceof Date)return r;if(typeof r=="string"){const t=Date.parse(r);if(isNaN(t))throw new Error(`Invalid date:[${r}]`);return new Date(t)}else if(typeof r=="number")return new Date(r);throw new Error(`Invalid date:[${r}]`)}static review_log(r){return{...r,due:B.time(r.due),rating:B.rating(r.rating),state:B.state(r.state),review:B.time(r.review)}}}Date.prototype.scheduler=function(e,r){return Qe(this,e,r)},Date.prototype.diff=function(e,r){return Xe(this,e,r)},Date.prototype.format=function(){return er(this)},Date.prototype.dueFormat=function(e,r,t){return rr(this,e,r,t)};function Qe(e,r,t){return new Date(t?B.time(e).getTime()+r*24*60*60*1e3:B.time(e).getTime()+r*60*1e3)}function Xe(e,r,t){if(!e||!r)throw new Error("Invalid date");const n=B.time(e).getTime()-B.time(r).getTime();let s=0;switch(t){case"days":s=Math.floor(n/864e5);break;case"minutes":s=Math.floor(n/6e4);break}return s}function er(e){const r=B.time(e),t=r.getFullYear(),n=r.getMonth()+1,s=r.getDate(),o=r.getHours(),l=r.getMinutes(),m=r.getSeconds();return`${t}-${z(n)}-${z(s)} ${z(o)}:${z(l)}:${z(m)}`}function z(e){return e<10?`0${e}`:`${e}`}const ee=[60,60,24,31,12],re=["second","min","hour","day","month","year"];function rr(e,r,t,n=re){e=B.time(e),r=B.time(r),n.length!==re.length&&(n=re);let s=e.getTime()-r.getTime(),o;for(s/=1e3,o=0;o<ee.length&&!(s<ee[o]);o++)s/=ee[o];return`${Math.floor(s)}${t?n[o]:""}`}Object.freeze([W.Again,W.Hard,W.Good,W.Easy]);function tr(e,r){return{due:e?B.time(e):new Date,stability:0,difficulty:0,elapsed_days:0,scheduled_days:0,reps:0,lapses:0,state:Z.New,last_review:void 0}}var nr=(e=>(e.SCHEDULER="Scheduler",e.SEED="Seed",e))(nr||{});const te="offscreen.html";let G=null;const sr=new Ke;async function or(){const e=await sr.acquire();try{if((await O.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[O.runtime.getURL(te)]})).length>0)return;if(G){console.log("[DB Util] Waiting for existing offscreen document creation..."),await G;return}console.log("[DB Util] Creating offscreen document..."),G=chrome.offscreen.createDocument({url:te,reasons:["DOM_PARSER"],justification:"Provides PGlite database operations."});try{await G,console.log("[DB Util] Offscreen document created successfully.")}catch(t){if(console.error("[DB Util] Error creating offscreen document:",t),(await O.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[O.runtime.getURL(te)]})).length===0)throw new Error(`Offscreen document creation failed: ${t.message}`);console.warn("[DB Util] Offscreen document existed despite creation error/race condition.")}finally{G=null}}finally{e()}}async function ne(e,r){return await or(),M("dbQuery",{sql:e,params:r||[]})}async function ar(e,r=new Date){var g,c;const t=tr(r),n=Z[t.state],s=`
        INSERT INTO flashcards (
            type, front, back, cloze_text, source_url, source_highlight, 
            source_language, target_language, context, tags, 
            due, stability, difficulty, elapsed_days, scheduled_days, 
            reps, lapses, state, last_review
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
        RETURNING *; 
    `,o=[e.type,e.front??null,e.back??null,e.cloze_text??null,e.source_url??null,e.source_highlight??null,e.source_language??null,e.target_language??null,e.context??null,e.tags??null,t.due.toISOString(),t.stability,t.difficulty,t.elapsed_days,t.scheduled_days,t.reps,t.lapses,n,((g=t.last_review)==null?void 0:g.toISOString())??null],l=await ne(s,o);if(!((c=l==null?void 0:l.rows)!=null&&c[0]))throw new Error("Failed to create flashcard");return l.rows[0]}async function ir(e){var s;const r=`
        INSERT INTO chat_messages (role, content, bookmark_id, flashcard_id)
        VALUES ($1, $2, $3, $4)
        RETURNING *;
    `,t=[e.role,e.content??null,e.bookmark_id??null,e.flashcard_id??null],n=await ne(r,t);if(!((s=n==null?void 0:n.rows)!=null&&s[0]))throw new Error("Failed to create chat message");return console.log("[db.ts createChatMessage] Raw DB result row:",n.rows[0]),n.rows[0]}async function lr(e){var T;const{prompt:r,history:t=[],config:n,sendChunk:s}=e,o=n,l=o.chatModel,g=`${o.endpoint.replace(/\/$/,"")}/api/chat`;console.log(`[ollamaProvider] Sending chat request to ${g} with model ${l}`);const c=await fetch(g,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({model:l,messages:[...t,{role:"user",content:r}],stream:!0})});if(!c.ok||!c.body){const v=await c.text().catch(()=>"Failed to read error body");throw new Error(`Ollama API error (${c.status}): ${v}`)}const f=c.body.getReader(),y=new TextDecoder;let w="";for(;;){const{done:v,value:b}=await f.read();if(v)break;w+=y.decode(b,{stream:!0});const E=w.split(`
`);w=E.pop()||"";for(const S of E)if(S.trim()!=="")try{const $=JSON.parse(S);let N=null;(T=$.message)!=null&&T.content?N={status:"chunk",content:$.message.content}:$.done&&(N={status:"done",stats:{model:$.model,created_at:$.created_at,total_duration:$.total_duration,load_duration:$.load_duration,prompt_eval_count:$.prompt_eval_count,prompt_eval_duration:$.prompt_eval_duration,eval_count:$.eval_count,eval_duration:$.eval_duration}},console.log("[ollamaProvider] Stream finished.",N.stats)),N&&s(N)}catch($){console.error("[ollamaProvider] Failed to parse Ollama stream chunk:",S,$)}}w.trim()&&console.warn("[ollamaProvider] Stream ended with unprocessed buffer:",w)}async function cr(e){const{prompt:r,history:t=[],config:n}=e,s=n,o=s.chatModel,m=`${s.endpoint.replace(/\/$/,"")}/api/chat`;console.log(`[ollamaProvider] Sending NON-STREAMING chat request to ${m} with model ${o}`);try{const g=await fetch(m,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({model:o,messages:[...t,{role:"user",content:r}],stream:!1})});if(!g.ok){const f=await g.text().catch(()=>"Failed to read error body");return console.error(`[ollamaProvider] Chat Completion API error (${g.status}): ${f}`),null}const c=await g.json();return!c.message||typeof c.message.content!="string"?(console.error("[ollamaProvider] Invalid response format from Ollama Chat API (non-streaming). 'message.content' not found or not a string.",c),null):(console.log("[ollamaProvider] Received non-streaming response:",c),{message:{role:"assistant",content:c.message.content},usage:{prompt_tokens:c.prompt_eval_count,completion_tokens:c.eval_count}})}catch(g){return console.error("[ollamaProvider] Network or parsing error during chat completion:",g),null}}async function gr(e){const{content:r,config:t}=e,n=t;if(!n.embeddingModel)throw new Error("Ollama configuration missing required embeddingModel.");const s=n.embeddingModel,l=`${n.endpoint.replace(/\/$/,"")}/api/embeddings`;if(console.log(`[ollamaProvider] Requesting embeddings from ${l} with model ${s}`),Array.isArray(r))throw new Error("Ollama embedding currently only supports single string input in this implementation.");const m=await fetch(l,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({model:s,prompt:r})});if(!m.ok){const c=await m.text().catch(()=>"Failed to read error body");throw new Error(`Ollama Embeddings API error (${m.status}): ${c}`)}const g=await m.json();if(!g.embedding||!Array.isArray(g.embedding))throw new Error("Invalid response format from Ollama Embeddings API. 'embedding' array not found.");return{embeddings:[g.embedding]}}const we={providerId:"ollama",streamChat:lr,chatCompletion:cr,getEmbeddings:gr};async function mr(e){var v,b,E;const{prompt:r,history:t=[],config:n,sendChunk:s}=e,o=n,l=o.chatModel,m=o.apiKey,g="https://openrouter.ai/api/v1/chat/completions";console.log(`[openRouterProvider] Sending chat request to ${g} with model ${l}`);const c=await fetch(g,{method:"POST",headers:{Authorization:`Bearer ${m}`,"Content-Type":"application/json"},body:JSON.stringify({model:l,messages:[...t,{role:"user",content:r}],stream:!0})});if(!c.ok||!c.body){const S=await c.text().catch(()=>"Failed to read error body");throw new Error(`OpenRouter API error (${c.status}): ${S}`)}const f=c.body.getReader(),y=new TextDecoder;let w="",T=!1;for(;!T;){const{done:S,value:$}=await f.read();T=S,w+=y.decode($,{stream:!0});const N=w.split(`
`);w=N.pop()||"";for(const J of N)if(J.startsWith("data: ")){const I=J.substring(6).trim();if(I==="[DONE]"){s({status:"done",stats:{}}),console.log("[openRouterProvider] Stream finished."),T=!0;break}try{const d=(E=(b=(v=JSON.parse(I).choices)==null?void 0:v[0])==null?void 0:b.delta)==null?void 0:E.content;d&&s({status:"chunk",content:d})}catch(u){console.error("[openRouterProvider] Failed to parse stream chunk:",I,u)}}}w.trim()&&console.warn("[openRouterProvider] Stream ended with unprocessed buffer:",w)}const ur={providerId:"openrouter",streamChat:mr};let se=null;async function oe(){var e,r;if(se)return se;console.log("[llmService] Loading user configuration from DB...");try{const t=await ne("SELECT config_json FROM user_configuration WHERE id = 1;");if((r=(e=t==null?void 0:t.rows)==null?void 0:e[0])!=null&&r.config_json){const n=JSON.parse(t.rows[0].config_json);return console.log("[llmService] Loaded config:",n),se=n,n}else return console.warn("[llmService] No configuration found in database."),null}catch(t){return console.error("[llmService] Error loading configuration:",t),null}}async function dr(e){const{prompt:r,history:t,config:n}=e;console.log(`[llmService] Routing chat stream for provider: ${n.provider}`);const s=ae(n);if(!s)throw new Error(`Unsupported provider: ${n.provider}`);if(!s.streamChat)throw new Error(`Provider ${n.provider} does not support streaming chat.`);const o={prompt:r,history:t,config:n,sendChunk:l=>{M("ollamaResponse",l).catch(m=>console.error("Failed to send chunk to UI:",m))}};try{await s.streamChat(o)}catch(l){console.error(`[llmService] Error during streamChat for ${n.provider}:`,l),M("ollamaResponse",{status:"error",error:l instanceof Error?l.message:String(l)}).catch(m=>console.error("Failed to send error chunk to UI:",m))}}function Ar(e,r){return`
Generate two types of flashcards from the text below: a concise "Flashcard" (Front/Back) and a "Cloze" deletion card.

Text Selection:
"""
${e}
"""


Instructions:

1.  **Flashcard (Front/Back):**
    *   Front: A short topic or concept (max 8 words).
    *   Back: A concise fact or definition related to the front (max 8 words).
    *   **IMPORTANT:** Do NOT include trailing punctuation. Back should ONLY contain the fact, no filler.

2.  **Cloze Card:**
    *   Create a single sentence using the main idea.
    *   Replace the single most *meaningful* keyword/phrase with {{c1::answer}}.
    *   **AVOID** deleting trivial words (the, is, a) or the obvious main subject.

3.  **Output Format:**
    *   Return ONLY a valid JSON object. No extra text, explanations, or markdown.
    *   Use this EXACT structure:
    \`\`\`json
    {
      "flashcard": { "front": "topic/concept", "back": "concise fact" },
      "cloze": { "text": "Sentence with {{c1::answer}} deletion." }
    }
    \`\`\`

Examples:

--- Example 1 ---
Input Text: "The Eiffel Tower, located in Paris, France, was completed in 1889."
Output JSON:
\`\`\`json
{
  "flashcard": { "front": "Eiffel Tower Location", "back": "Paris, France" },
  "cloze": { "text": "The Eiffel Tower, located in Paris, France, was completed in {{c1::1889}}" }
}
\`\`\`
(Flashcard: Good - concise topic/fact. Cloze: Good - specific detail deleted.)

--- Example 2 ---
Input Text: "Photosynthesis is the process used by plants to convert light energy into chemical energy."
Output JSON:
\`\`\`json
{
  "flashcard": { "front": "Photosynthesis", "back": "Converts light to chemical energy" },
  "cloze": { "text": "Photosynthesis is the process used by plants to convert {{c1::light energy}} into chemical energy" }
}
\`\`\`
(Flashcard: Good - concept/definition. Cloze: Good - key concept deleted.)

--- Example 3 ---
Input Text: "The Wachowskis wrote and directed the Matrix film series."
Output JSON:
\`\`\`json
{
  "flashcard": { "front": "The Matrix Directors", "back": "The Wachowskis" },
  "cloze": { "text": "The {{c1::Wachowskis}} wrote and directed the Matrix film series" }
}
\`\`\`
(Flashcard: Good - specific role. Cloze: Better - deleted the directors instead of the trivial 'Matrix'.)

--- Example 4 (Bad Examples) ---
Input Text: "React is a JavaScript library for building user interfaces."
Bad Flashcard Back: "React is a JS library for UIs." (Trailing period)
Bad Flashcard Back: "It is a library for building UIs" (Exceeds 8 words, filler)
Bad Cloze: "React is a JavaScript library for building {{c1::user interfaces}}" (Okay, but less ideal than deleting 'JavaScript library')
Bad Cloze: "{{c1::React}} is a JavaScript library for building user interfaces." (Trivial deletion of main subject)

Now, generate the flashcards for the provided text selection. Output ONLY the JSON object:
`.trim()}function ae(e){switch(e.provider){case"ollama":return we;case"openrouter":return ur;default:return e.endpoint?(console.warn(`[llmService] Using ollamaProvider for potentially compatible provider: ${e.provider}`),we):(console.error(`[llmService] Unsupported provider found in config: ${e.provider}`),null)}}async function fr(e){var l,m,g,c,f,y;console.log("[llmService] Generating flashcard content for text:",e.substring(0,50)+"...");const r=await oe();if(!r)throw new Error("LLM configuration not found.");const t=ae(r);if(!t)throw new Error(`Unsupported provider: ${r.provider}`);if(!t.streamChat)return console.error(`[llmService] Provider ${r.provider} does not support streaming chat. Cannot generate flashcards.`),null;const n=Ar(e);let s="",o=null;console.log("[llmService] Sending flashcard generation prompt via streamChat...");try{if(await new Promise((w,T)=>{const v={prompt:n,config:r,history:[],sendChunk:b=>{b.status==="chunk"&&b.content?s+=b.content:b.status==="error"?(console.error("[llmService flashcard stream] Received error chunk:",b.error),o=b.error||"Unknown streaming error"):(b.status==="done"||b.status==="complete")&&(console.log("[llmService flashcard stream] Stream finished."),w())}};t.streamChat(v).catch(T)}),o&&console.error("[llmService] Flashcard stream completed with error:",o),!s)return console.error("[llmService] Flashcard stream completed but accumulated content is empty."),null;console.log("[llmService] Received accumulated stream response for parsing:",s);try{const w=s.match(/```json\s*([\s\S]*?)\s*```|({[\s\S]*})/);if(!w||!w[1]&&!w[2]){console.error("[llmService] Could not find JSON block in the accumulated stream response.");try{const b=JSON.parse(s.trim());return(l=b.flashcard)!=null&&l.front&&((m=b.flashcard)!=null&&m.back)&&((g=b.cloze)!=null&&g.text)?(console.log("[llmService] Successfully parsed flashcard JSON from raw stream response (fallback)."),b):(console.error("[llmService] Parsed fallback stream JSON lacks expected structure:",b),null)}catch(b){return console.error("[llmService] Failed to parse JSON directly from accumulated stream (fallback failed):",b),null}}const T=w[1]||w[2],v=JSON.parse(T.trim());return(c=v.flashcard)!=null&&c.front&&((f=v.flashcard)!=null&&f.back)&&((y=v.cloze)!=null&&y.text)?(console.log("[llmService] Successfully parsed flashcard JSON from accumulated stream response."),v):(console.error("[llmService] Parsed stream JSON lacks expected structure (flashcard/cloze):",v),null)}catch(w){return console.error("[llmService] Error parsing JSON from accumulated stream response:",w),console.error("--- Accumulated Raw Content ---"),console.error(s),console.error("--- End Accumulated Raw Content ---"),null}}catch(w){return console.error("[llmService] Error during flashcard generation stream setup or promise handling:",w),null}}async function hr(e,r){var o,l;console.log(`[llmService] Translating text to ${r}: "${e.substring(0,50)}..."`);const t=await oe();if(!t)return console.error("[llmService translateText] Cannot translate: LLM config not loaded."),null;const n=ae(t);if(!(n!=null&&n.chatCompletion))return console.error(`[llmService translateText] Provider ${t.provider} does not support 'chatCompletion'.`),null;const s=`Translate the following text accurately to ${r}. Output ONLY the translated text, nothing else:

Text to translate:
"""
${e}
"""

Translated text:`;console.log(`[llmService translateText] Sending translation prompt to ${t.provider}...`);try{const m=await n.chatCompletion({prompt:s,config:t,history:[]}),g=(l=(o=m==null?void 0:m.message)==null?void 0:o.content)==null?void 0:l.trim();return g?(console.log("[llmService translateText] Received translation:",g),g):(console.error("[llmService translateText] LLM response was empty or invalid."),null)}catch(m){return console.error("[llmService translateText] Error during translation LLM call:",m),null}}console.log("Background script loaded.");const be="offscreen.html";async function pr(){return(await O.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[O.runtime.getURL(be)]})).length>0}async function ye(){await pr()?console.log("[Background] Offscreen document already exists."):(console.log("[Background] Creating offscreen document..."),await O.offscreen.createDocument({url:be,reasons:[O.offscreen.Reason.LOCAL_STORAGE],justification:"Database operations using PGlite"}),console.log("[Background] Offscreen document created."))}const xr=D(()=>{console.log("WXT Background defined"),q("clipPage",async e=>{console.log("Background: Received clipPage message",e.data);const{title:r,url:t}=e.data,n="INSERT INTO clips (title, url) VALUES (?, ?);",s=[r,t];console.log("Background: Sending dbExec message to offscreen for clipping...");try{const o=await M("dbExec",{data:{sql:n,params:s}});console.log("Background: Offscreen dbExec response:",o),console.log(`Background: Successfully clipped ${t}`),O.notifications.create(`clip-success-${Date.now()}`,{type:"basic",iconUrl:O.runtime.getURL("/icon/128.png"),title:"Bookmark Saved",message:`Saved: ${r}`,priority:0})}catch(o){console.error("Background: Error executing clip via offscreen:",o),O.notifications.create(`clip-error-${Date.now()}`,{type:"basic",iconUrl:O.runtime.getURL("/icon/128.png"),title:"Bookmark Saving Failed",message:`Could not save ${r}. Error: ${o instanceof Error?o.message:String(o)}`,priority:1})}}),q("getOllamaModels",async e=>{console.log("[Background] Received getOllamaModels message",e.data);const{endpoint:r}=e.data,t="getOllamaModelsResult";if(!r){console.error("[Background] Error: Ollama endpoint not provided."),M(t,{endpoint:r,success:!1,error:"Ollama endpoint not provided."}).catch(s=>console.error(`[Background] Failed to send ${t} error:`,s));return}const n=`${r}/api/tags`;console.log(`[Background] Attempting to fetch models from: ${n}`);try{const s={method:"GET",headers:{Accept:"application/json"}};console.log("[Background] Fetch options:",s);const o=await fetch(n,s);if(console.log(`[Background] Fetch response status: ${o.status}, OK: ${o.ok}`),!o.ok){let g="[Could not read error body]";try{g=await o.text()}catch{}throw console.error(`[Background] Fetch failed: Status ${o.status}. Body:`,g),new Error(`Failed to fetch Ollama models: ${o.status} ${o.statusText}`)}const l=await o.json(),m=Array.isArray(l==null?void 0:l.models)?l.models.map(g=>({id:g.name,name:g.name})):[];console.log("[Background] Successfully fetched Ollama models:",m),M(t,{endpoint:r,success:!0,models:m}).catch(g=>console.error(`[Background] Failed to send ${t} success:`,g))}catch(s){console.error("[Background] Error during fetch operation:",s);let o=s instanceof Error?s.message:"Unknown error fetching models.";o.includes("Failed to fetch")&&(o+=". Ensure Ollama is running and reachable, and check extension host permissions."),M(t,{endpoint:r,success:!1,error:o}).catch(l=>console.error(`[Background] Failed to send ${t} error:`,l))}}),q("ollamaChatRequest",async e=>{console.log("Background: Received ollamaChatRequest",e.data);const{prompt:r,history:t}=e.data,n=await oe();if(!n){console.error("Background: Cannot process chat request, user config not found."),M("ollamaResponse",{model:"unknown",created_at:new Date().toISOString(),status:"error",error:"LLM configuration not found. Please set it up in the settings."}).catch(s=>console.error("Failed to send config error message:",s));return}try{await dr({prompt:r,history:t||[],config:n}),console.log("Background: streamChatResponse processing initiated.")}catch(s){console.error("[Background] Error invoking streamChatResponse:",s),M("ollamaResponse",{model:n.chatModel||"unknown",created_at:new Date().toISOString(),status:"error",error:s instanceof Error?s.message:"Error during streaming"}).catch(o=>console.error("Failed to send stream error message:",o))}}),q("generateFlashcardContent",async e=>{console.log("[Background] Received generateFlashcardContent message",e.data);const{text:r}=e.data,t="flashcardGenerationResult";if(!r){console.error("[Background] No text provided for flashcard generation."),M(t,{data:null,error:"No text provided"}).catch(n=>console.error("Failed to send error result:",n));return}try{const n=await fr(r);console.log("[Background] Received result from llmService:",n),await new Promise(s=>setTimeout(s,50)),console.log("[Background] Attempting to send flashcard result after delay..."),M(t,{data:n,error:void 0}).catch(s=>console.error("Failed to send flashcard result:",s))}catch(n){console.error("[Background] Error during flashcard generation:",n),M(t,{data:null,error:n.message||"Unknown error during generation"}).catch(s=>console.error("Failed to send error result:",s))}}),q("getPageInfo",async()=>{console.log("[Background] Received getPageInfo request.");try{const r=(await O.tabs.query({active:!0,currentWindow:!0}))[0];return r&&r.url&&r.title?(console.log("[Background] Sending page info:",{title:r.title,url:r.url}),{title:r.title,url:r.url}):(console.warn("[Background] Could not get active tab info."),null)}catch(e){return console.error("[Background] Error getting page info:",e),null}}),q("getSelectedText",async()=>{var e;console.log("[Background] Received getSelectedText request.");try{const t=(await O.tabs.query({active:!0,currentWindow:!0}))[0],n=t==null?void 0:t.id;if(n&&((e=t.url)!=null&&e.startsWith("http"))){console.log(`[Background] Sending _requestSelectionFromContentScript to tab ${n}`);const s=await M("_requestSelectionFromContentScript",void 0,{tabId:n});return console.log(`[Background] Received response from content script for tab ${n}:`,s),s&&typeof s.text=="string"?{text:s.text}:(console.warn(`[Background] Invalid or empty response from content script for tab ${n}:`,s),null)}else return console.log("[Background] Cannot get selection from non-http(s) URL or no active tab ID."),null}catch(r){return console.error("[Background] Error getting selected text:",r),r instanceof Error&&(r.message.includes("Could not establish connection")||r.message.includes("No receiving end"))&&console.warn("[Background] Content script likely not injected or not responding on the active page."),null}}),q("translateText",async e=>{console.log("[Background] Received translateText request:",e.data);const{text:r,targetLang:t}=e.data;if(!r||!t)throw console.error("[Background] Missing text or targetLang for translation."),new Error("Missing text or target language for translation.");try{const n=await hr(r,t);if(console.log("[Background] Translation result from llmService:",n),n===null)throw new Error("Translation failed or returned null.");return n}catch(n){throw console.error("[Background] Error during translation:",n),new Error(`Translation failed: ${n.message||String(n)}`)}}),q("saveFlashcardAndNotify",async e=>{console.log("[Background] Received saveFlashcardAndNotify request:",e.data);const{cardData:r}=e.data;if(!r)throw console.error("[Background] No cardData provided for saveFlashcardAndNotify."),new Error("No flashcard data provided.");try{const t=await ar(r);return console.log("[Background] Flashcard created in DB:",t),await ir({role:"flashcard",flashcard_id:t.id}),console.log("[Background] Associated chat message created for flashcard ID:",t.id),t}catch(t){throw console.error("[Background] Error processing saveFlashcardAndNotify:",t),new Error(`Failed to save flashcard: ${t.message||String(t)}`)}}),O.runtime.onInstalled.addListener(async e=>{if(console.log("Extension installed:",e),e.reason==="install"){console.log("Performing first-time setup..."),await ye().catch(t=>{console.error("[Background] Initial setupOffscreenDocument failed on install:",t)});const r=O.runtime.getURL("onboarding.html");await O.tabs.create({url:r,active:!0}),console.log(`Opened onboarding page: ${r}`)}else e.reason==="update"&&console.log(`[Background] Updated from ${e.previousVersion} to ${O.runtime.getManifest().version}`)}),O.runtime.onStartup.addListener(async()=>{console.log("[Background] Browser startup detected. Setting up offscreen document...");try{await ye(),console.log("[Background] Offscreen document setup complete on startup.")}catch(e){console.error("[Background] setupOffscreenDocument failed on startup:",e)}}),console.log("Background script setup complete.")});function vr(){}(ke=(ve=globalThis.browser)==null?void 0:ve.runtime)!=null&&ke.id?globalThis.browser:globalThis.chrome;function Y(e,...r){}const wr={debug:(...e)=>Y(console.debug,...e),log:(...e)=>Y(console.log,...e),warn:(...e)=>Y(console.warn,...e),error:(...e)=>Y(console.error,...e)};let ie;try{ie=xr.main(),ie instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(e){throw wr.error("The background crashed on startup!"),e}return ie}();
background;
