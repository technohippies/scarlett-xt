var background=function(){"use strict";var br=Object.defineProperty;var yr=(q,F,D)=>F in q?br(q,F,{enumerable:!0,configurable:!0,writable:!0,value:D}):q[F]=D;var Ee=(q,F,D)=>yr(q,typeof F!="symbol"?F+"":F,D);var ve,ke;function q(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}var F={exports:{}},D=F.exports,ge;function Se(){return ge||(ge=1,function(e,r){(function(t,n){n(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:D,function(t){if(!(globalThis.chrome&&globalThis.chrome.runtime&&globalThis.chrome.runtime.id))throw new Error("This script should only be loaded in a browser extension.");if(globalThis.browser&&globalThis.browser.runtime&&globalThis.browser.runtime.id)t.exports=globalThis.browser;else{const n="The message port closed before a response was received.",s=o=>{const l={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(l).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class m extends WeakMap{constructor(d,a=void 0){super(a),this.createItem=d}get(d){return this.has(d)||this.set(d,this.createItem(d)),super.get(d)}}const g=u=>u&&typeof u=="object"&&typeof u.then=="function",c=(u,d)=>(...a)=>{o.runtime.lastError?u.reject(new Error(o.runtime.lastError.message)):d.singleCallbackArg||a.length<=1&&d.singleCallbackArg!==!1?u.resolve(a[0]):u.resolve(a)},A=u=>u==1?"argument":"arguments",y=(u,d)=>function(i,...h){if(h.length<d.minArgs)throw new Error(`Expected at least ${d.minArgs} ${A(d.minArgs)} for ${u}(), got ${h.length}`);if(h.length>d.maxArgs)throw new Error(`Expected at most ${d.maxArgs} ${A(d.maxArgs)} for ${u}(), got ${h.length}`);return new Promise((x,k)=>{if(d.fallbackToNoCallback)try{i[u](...h,c({resolve:x,reject:k},d))}catch(p){console.warn(`${u} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,p),i[u](...h),d.fallbackToNoCallback=!1,d.noCallback=!0,x()}else d.noCallback?(i[u](...h),x()):i[u](...h,c({resolve:x,reject:k},d))})},w=(u,d,a)=>new Proxy(d,{apply(i,h,x){return a.call(h,u,...x)}});let $=Function.call.bind(Object.prototype.hasOwnProperty);const v=(u,d={},a={})=>{let i=Object.create(null),h={has(k,p){return p in u||p in i},get(k,p,_){if(p in i)return i[p];if(!(p in u))return;let f=u[p];if(typeof f=="function")if(typeof d[p]=="function")f=w(u,u[p],d[p]);else if($(a,p)){let P=y(p,a[p]);f=w(u,u[p],P)}else f=f.bind(u);else if(typeof f=="object"&&f!==null&&($(d,p)||$(a,p)))f=v(f,d[p],a[p]);else if($(a,"*"))f=v(f,d[p],a["*"]);else return Object.defineProperty(i,p,{configurable:!0,enumerable:!0,get(){return u[p]},set(P){u[p]=P}}),f;return i[p]=f,f},set(k,p,_,f){return p in i?i[p]=_:u[p]=_,!0},defineProperty(k,p,_){return Reflect.defineProperty(i,p,_)},deleteProperty(k,p){return Reflect.deleteProperty(i,p)}},x=Object.create(u);return new Proxy(x,h)},b=u=>({addListener(d,a,...i){d.addListener(u.get(a),...i)},hasListener(d,a){return d.hasListener(u.get(a))},removeListener(d,a){d.removeListener(u.get(a))}}),S=new m(u=>typeof u!="function"?u:function(a){const i=v(a,{},{getContent:{minArgs:0,maxArgs:0}});u(i)}),C=new m(u=>typeof u!="function"?u:function(a,i,h){let x=!1,k,p=new Promise(T=>{k=function(B){x=!0,T(B)}}),_;try{_=u(a,i,k)}catch(T){_=Promise.reject(T)}const f=_!==!0&&g(_);if(_!==!0&&!f&&!x)return!1;const P=T=>{T.then(B=>{h(B)},B=>{let j;B&&(B instanceof Error||typeof B.message=="string")?j=B.message:j="An unexpected error occurred",h({__mozWebExtensionPolyfillReject__:!0,message:j})}).catch(B=>{console.error("Failed to send onMessage rejected reply",B)})};return P(f?_:p),!0}),O=({reject:u,resolve:d},a)=>{o.runtime.lastError?o.runtime.lastError.message===n?d():u(new Error(o.runtime.lastError.message)):a&&a.__mozWebExtensionPolyfillReject__?u(new Error(a.message)):d(a)},N=(u,d,a,...i)=>{if(i.length<d.minArgs)throw new Error(`Expected at least ${d.minArgs} ${A(d.minArgs)} for ${u}(), got ${i.length}`);if(i.length>d.maxArgs)throw new Error(`Expected at most ${d.maxArgs} ${A(d.maxArgs)} for ${u}(), got ${i.length}`);return new Promise((h,x)=>{const k=O.bind(null,{resolve:h,reject:x});i.push(k),a.sendMessage(...i)})},J={devtools:{network:{onRequestFinished:b(S)}},runtime:{onMessage:b(C),onMessageExternal:b(C),sendMessage:N.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:N.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},I={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return l.privacy={network:{"*":I},services:{"*":I},websites:{"*":I}},v(o,J,l)};t.exports=s(chrome)}})}(F)),F.exports}var Ce=Se();const E=q(Ce),_e=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,globalThis.DOMException,globalThis.AssertionError,globalThis.SystemError].filter(Boolean).map(e=>[e.name,e]),Te=new Map(_e);class K extends Error{constructor(t){super(K._prepareSuperMessage(t));Ee(this,"name","NonError")}static _prepareSuperMessage(t){try{return JSON.stringify(t)}catch{return String(t)}}}const $e=[{property:"name",enumerable:!1},{property:"message",enumerable:!1},{property:"stack",enumerable:!1},{property:"code",enumerable:!0},{property:"cause",enumerable:!1}],Q=new WeakSet,Oe=e=>{Q.add(e);const r=e.toJSON();return Q.delete(e),r},me=e=>Te.get(e)??Error,X=({from:e,seen:r,to:t,forceEnumerable:n,maxDepth:s,depth:o,useToJSON:l,serialize:m})=>{if(!t)if(Array.isArray(e))t=[];else if(!m&&ue(e)){const c=me(e.name);t=new c}else t={};if(r.push(e),o>=s)return t;if(l&&typeof e.toJSON=="function"&&!Q.has(e))return Oe(e);const g=c=>X({from:c,seen:[...r],forceEnumerable:n,maxDepth:s,depth:o,useToJSON:l,serialize:m});for(const[c,A]of Object.entries(e)){if(A&&A instanceof Uint8Array&&A.constructor.name==="Buffer"){t[c]="[object Buffer]";continue}if(A!==null&&typeof A=="object"&&typeof A.pipe=="function"){t[c]="[object Stream]";continue}if(typeof A!="function"){if(!A||typeof A!="object"){try{t[c]=A}catch{}continue}if(!r.includes(e[c])){o++,t[c]=g(e[c]);continue}t[c]="[Circular]"}}for(const{property:c,enumerable:A}of $e)typeof e[c]<"u"&&e[c]!==null&&Object.defineProperty(t,c,{value:ue(e[c])?g(e[c]):e[c],enumerable:n?!0:A,configurable:!0,writable:!0});return t};function Pe(e,r={}){const{maxDepth:t=Number.POSITIVE_INFINITY,useToJSON:n=!0}=r;return typeof e=="object"&&e!==null?X({from:e,seen:[],forceEnumerable:!0,maxDepth:t,depth:0,useToJSON:n,serialize:!0}):typeof e=="function"?`[Function: ${e.name||"anonymous"}]`:e}function Be(e,r={}){const{maxDepth:t=Number.POSITIVE_INFINITY}=r;if(e instanceof Error)return e;if(Re(e)){const n=me(e.name);return X({from:e,seen:[],to:new n,maxDepth:t,depth:0,serialize:!1})}return new K(e)}function ue(e){return!!e&&typeof e=="object"&&"name"in e&&"message"in e&&"stack"in e}function Re(e){return!!e&&typeof e=="object"&&"message"in e&&!Array.isArray(e)}var Ne=Object.defineProperty,Me=Object.defineProperties,Fe=Object.getOwnPropertyDescriptors,de=Object.getOwnPropertySymbols,Ie=Object.prototype.hasOwnProperty,Le=Object.prototype.propertyIsEnumerable,fe=(e,r,t)=>r in e?Ne(e,r,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[r]=t,Ae=(e,r)=>{for(var t in r||(r={}))Ie.call(r,t)&&fe(e,t,r[t]);if(de)for(var t of de(r))Le.call(r,t)&&fe(e,t,r[t]);return e},he=(e,r)=>Me(e,Fe(r)),Ue=(e,r,t)=>new Promise((n,s)=>{var o=g=>{try{m(t.next(g))}catch(c){s(c)}},l=g=>{try{m(t.throw(g))}catch(c){s(c)}},m=g=>g.done?n(g.value):Promise.resolve(g.value).then(o,l);m((t=t.apply(e,r)).next())});function je(e){let r,t={};function n(){Object.entries(t).length===0&&(r==null||r(),r=void 0)}let s=Math.floor(Math.random()*1e4);function o(){return s++}return{sendMessage(l,m,...g){return Ue(this,null,function*(){var c,A,y,w;const $={id:o(),type:l,data:m,timestamp:Date.now()},v=(A=yield(c=e.verifyMessageData)==null?void 0:c.call(e,$))!=null?A:$;(y=e.logger)==null||y.debug(`[messaging] sendMessage {id=${v.id}} ─ᐅ`,v,...g);const b=yield e.sendMessage(v,...g),{res:S,err:C}=b??{err:new Error("No response")};if((w=e.logger)==null||w.debug(`[messaging] sendMessage {id=${v.id}} ᐊ─`,{res:S,err:C}),C!=null)throw Be(C);return S})},onMessage(l,m){var g,c,A;if(r==null&&((g=e.logger)==null||g.debug(`[messaging] "${l}" initialized the message listener for this context`),r=e.addRootListener(y=>{var w,$;if(typeof y.type!="string"||typeof y.timestamp!="number"){if(e.breakError)return;const S=Error(`[messaging] Unknown message format, must include the 'type' & 'timestamp' fields, received: ${JSON.stringify(y)}`);throw(w=e.logger)==null||w.error(S),S}($=e==null?void 0:e.logger)==null||$.debug("[messaging] Received message",y);const v=t[y.type];if(v==null)return;const b=v(y);return Promise.resolve(b).then(S=>{var C,O;return(O=(C=e.verifyMessageData)==null?void 0:C.call(e,S))!=null?O:S}).then(S=>{var C;return(C=e==null?void 0:e.logger)==null||C.debug(`[messaging] onMessage {id=${y.id}} ─ᐅ`,{res:S}),{res:S}}).catch(S=>{var C;return(C=e==null?void 0:e.logger)==null||C.debug(`[messaging] onMessage {id=${y.id}} ─ᐅ`,{err:S}),{err:Pe(S)}})})),t[l]!=null){const y=Error(`[messaging] In this JS context, only one listener can be setup for ${l}`);throw(c=e.logger)==null||c.error(y),y}return t[l]=m,(A=e.logger)==null||A.log(`[messaging] Added listener for ${l}`),()=>{delete t[l],n()}},removeAllListeners(){Object.keys(t).forEach(l=>{delete t[l]}),n()}}}var V={exports:{}},qe=V.exports,pe;function De(){return pe||(pe=1,function(e,r){(function(t,n){n(e)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:qe,function(t){var n,s;if(!((s=(n=globalThis.chrome)==null?void 0:n.runtime)!=null&&s.id))throw new Error("This script should only be loaded in a browser extension.");if(typeof globalThis.browser>"u"||Object.getPrototypeOf(globalThis.browser)!==Object.prototype){const o="The message port closed before a response was received.",l=m=>{const g={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(g).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class c extends WeakMap{constructor(i,h=void 0){super(h),this.createItem=i}get(i){return this.has(i)||this.set(i,this.createItem(i)),super.get(i)}}const A=a=>a&&typeof a=="object"&&typeof a.then=="function",y=(a,i)=>(...h)=>{m.runtime.lastError?a.reject(new Error(m.runtime.lastError.message)):i.singleCallbackArg||h.length<=1&&i.singleCallbackArg!==!1?a.resolve(h[0]):a.resolve(h)},w=a=>a==1?"argument":"arguments",$=(a,i)=>function(x,...k){if(k.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${w(i.minArgs)} for ${a}(), got ${k.length}`);if(k.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${w(i.maxArgs)} for ${a}(), got ${k.length}`);return new Promise((p,_)=>{if(i.fallbackToNoCallback)try{x[a](...k,y({resolve:p,reject:_},i))}catch(f){console.warn(`${a} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,f),x[a](...k),i.fallbackToNoCallback=!1,i.noCallback=!0,p()}else i.noCallback?(x[a](...k),p()):x[a](...k,y({resolve:p,reject:_},i))})},v=(a,i,h)=>new Proxy(i,{apply(x,k,p){return h.call(k,a,...p)}});let b=Function.call.bind(Object.prototype.hasOwnProperty);const S=(a,i={},h={})=>{let x=Object.create(null),k={has(_,f){return f in a||f in x},get(_,f,P){if(f in x)return x[f];if(!(f in a))return;let T=a[f];if(typeof T=="function")if(typeof i[f]=="function")T=v(a,a[f],i[f]);else if(b(h,f)){let B=$(f,h[f]);T=v(a,a[f],B)}else T=T.bind(a);else if(typeof T=="object"&&T!==null&&(b(i,f)||b(h,f)))T=S(T,i[f],h[f]);else if(b(h,"*"))T=S(T,i[f],h["*"]);else return Object.defineProperty(x,f,{configurable:!0,enumerable:!0,get(){return a[f]},set(B){a[f]=B}}),T;return x[f]=T,T},set(_,f,P,T){return f in x?x[f]=P:a[f]=P,!0},defineProperty(_,f,P){return Reflect.defineProperty(x,f,P)},deleteProperty(_,f){return Reflect.deleteProperty(x,f)}},p=Object.create(a);return new Proxy(p,k)},C=a=>({addListener(i,h,...x){i.addListener(a.get(h),...x)},hasListener(i,h){return i.hasListener(a.get(h))},removeListener(i,h){i.removeListener(a.get(h))}}),O=new c(a=>typeof a!="function"?a:function(h){const x=S(h,{},{getContent:{minArgs:0,maxArgs:0}});a(x)}),N=new c(a=>typeof a!="function"?a:function(h,x,k){let p=!1,_,f=new Promise(j=>{_=function(L){p=!0,j(L)}}),P;try{P=a(h,x,_)}catch(j){P=Promise.reject(j)}const T=P!==!0&&A(P);if(P!==!0&&!T&&!p)return!1;const B=j=>{j.then(L=>{k(L)},L=>{let ce;L&&(L instanceof Error||typeof L.message=="string")?ce=L.message:ce="An unexpected error occurred",k({__mozWebExtensionPolyfillReject__:!0,message:ce})}).catch(L=>{console.error("Failed to send onMessage rejected reply",L)})};return B(T?P:f),!0}),J=({reject:a,resolve:i},h)=>{m.runtime.lastError?m.runtime.lastError.message===o?i():a(new Error(m.runtime.lastError.message)):h&&h.__mozWebExtensionPolyfillReject__?a(new Error(h.message)):i(h)},I=(a,i,h,...x)=>{if(x.length<i.minArgs)throw new Error(`Expected at least ${i.minArgs} ${w(i.minArgs)} for ${a}(), got ${x.length}`);if(x.length>i.maxArgs)throw new Error(`Expected at most ${i.maxArgs} ${w(i.maxArgs)} for ${a}(), got ${x.length}`);return new Promise((k,p)=>{const _=J.bind(null,{resolve:k,reject:p});x.push(_),h.sendMessage(...x)})},u={devtools:{network:{onRequestFinished:C(O)}},runtime:{onMessage:C(N),onMessageExternal:C(N),sendMessage:I.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:I.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},d={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return g.privacy={network:{"*":d},services:{"*":d},websites:{"*":d}},S(m,u,g)};t.exports=l(chrome)}else t.exports=globalThis.browser})}(V)),V.exports}var We=De();const H=q(We);function Je(e){return je(he(Ae({},e),{sendMessage(r,t){if(t==null)return H.runtime.sendMessage(r);const n=typeof t=="number"?{tabId:t}:t;return H.tabs.sendMessage(n.tabId,r,n.frameId!=null?{frameId:n.frameId}:void 0)},addRootListener(r){const t=(n,s)=>r(typeof n=="object"?he(Ae({},n),{sender:s}):n);return H.runtime.onMessage.addListener(t),()=>H.runtime.onMessage.removeListener(t)}}))}const xe=Je(),U=xe.onMessage,M=xe.sendMessage,ze=new Error("request for lock canceled");var Ge=function(e,r,t,n){function s(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function m(A){try{c(n.next(A))}catch(y){l(y)}}function g(A){try{c(n.throw(A))}catch(y){l(y)}}function c(A){A.done?o(A.value):s(A.value).then(m,g)}c((n=n.apply(e,r||[])).next())})};class Ve{constructor(r,t=ze){this._value=r,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(r=1,t=0){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);return new Promise((n,s)=>{const o={resolve:n,reject:s,weight:r,priority:t},l=we(this._queue,m=>t<=m.priority);l===-1&&r<=this._value?this._dispatchItem(o):this._queue.splice(l+1,0,o)})}runExclusive(r){return Ge(this,arguments,void 0,function*(t,n=1,s=0){const[o,l]=yield this.acquire(n,s);try{return yield t(o)}finally{l()}})}waitForUnlock(r=1,t=0){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);return this._couldLockImmediately(r,t)?Promise.resolve():new Promise(n=>{this._weightedWaiters[r-1]||(this._weightedWaiters[r-1]=[]),He(this._weightedWaiters[r-1],{resolve:n,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(r){this._value=r,this._dispatchQueue()}release(r=1){if(r<=0)throw new Error(`invalid weight ${r}: must be positive`);this._value+=r,this._dispatchQueue()}cancel(){this._queue.forEach(r=>r.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(r){const t=this._value;this._value-=r.weight,r.resolve([t,this._newReleaser(r.weight)])}_newReleaser(r){let t=!1;return()=>{t||(t=!0,this.release(r))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let r=this._value;r>0;r--){const t=this._weightedWaiters[r-1];t&&(t.forEach(n=>n.resolve()),this._weightedWaiters[r-1]=[])}else{const r=this._queue[0].priority;for(let t=this._value;t>0;t--){const n=this._weightedWaiters[t-1];if(!n)continue;const s=n.findIndex(o=>o.priority<=r);(s===-1?n:n.splice(0,s)).forEach(o=>o.resolve())}}}_couldLockImmediately(r,t){return(this._queue.length===0||this._queue[0].priority<t)&&r<=this._value}}function He(e,r){const t=we(e,n=>r.priority<=n.priority);e.splice(t+1,0,r)}function we(e,r){for(let t=e.length-1;t>=0;t--)if(r(e[t]))return t;return-1}var Ze=function(e,r,t,n){function s(o){return o instanceof t?o:new t(function(l){l(o)})}return new(t||(t=Promise))(function(o,l){function m(A){try{c(n.next(A))}catch(y){l(y)}}function g(A){try{c(n.throw(A))}catch(y){l(y)}}function c(A){A.done?o(A.value):s(A.value).then(m,g)}c((n=n.apply(e,r||[])).next())})};class Ye{constructor(r){this._semaphore=new Ve(1,r)}acquire(){return Ze(this,arguments,void 0,function*(r=0){const[,t]=yield this._semaphore.acquire(1,r);return t})}runExclusive(r,t=0){return this._semaphore.runExclusive(()=>r(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(r=0){return this._semaphore.waitForUnlock(1,r)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}var Z=(e=>(e[e.New=0]="New",e[e.Learning=1]="Learning",e[e.Review=2]="Review",e[e.Relearning=3]="Relearning",e))(Z||{}),W=(e=>(e[e.Manual=0]="Manual",e[e.Again=1]="Again",e[e.Hard=2]="Hard",e[e.Good=3]="Good",e[e.Easy=4]="Easy",e))(W||{});class R{static card(r){return{...r,state:R.state(r.state),due:R.time(r.due),last_review:r.last_review?R.time(r.last_review):void 0}}static rating(r){if(typeof r=="string"){const t=r.charAt(0).toUpperCase(),n=r.slice(1).toLowerCase(),s=W[`${t}${n}`];if(s===void 0)throw new Error(`Invalid rating:[${r}]`);return s}else if(typeof r=="number")return r;throw new Error(`Invalid rating:[${r}]`)}static state(r){if(typeof r=="string"){const t=r.charAt(0).toUpperCase(),n=r.slice(1).toLowerCase(),s=Z[`${t}${n}`];if(s===void 0)throw new Error(`Invalid state:[${r}]`);return s}else if(typeof r=="number")return r;throw new Error(`Invalid state:[${r}]`)}static time(r){if(typeof r=="object"&&r instanceof Date)return r;if(typeof r=="string"){const t=Date.parse(r);if(isNaN(t))throw new Error(`Invalid date:[${r}]`);return new Date(t)}else if(typeof r=="number")return new Date(r);throw new Error(`Invalid date:[${r}]`)}static review_log(r){return{...r,due:R.time(r.due),rating:R.rating(r.rating),state:R.state(r.state),review:R.time(r.review)}}}Date.prototype.scheduler=function(e,r){return Ke(this,e,r)},Date.prototype.diff=function(e,r){return Qe(this,e,r)},Date.prototype.format=function(){return Xe(this)},Date.prototype.dueFormat=function(e,r,t){return er(this,e,r,t)};function Ke(e,r,t){return new Date(t?R.time(e).getTime()+r*24*60*60*1e3:R.time(e).getTime()+r*60*1e3)}function Qe(e,r,t){if(!e||!r)throw new Error("Invalid date");const n=R.time(e).getTime()-R.time(r).getTime();let s=0;switch(t){case"days":s=Math.floor(n/864e5);break;case"minutes":s=Math.floor(n/6e4);break}return s}function Xe(e){const r=R.time(e),t=r.getFullYear(),n=r.getMonth()+1,s=r.getDate(),o=r.getHours(),l=r.getMinutes(),m=r.getSeconds();return`${t}-${z(n)}-${z(s)} ${z(o)}:${z(l)}:${z(m)}`}function z(e){return e<10?`0${e}`:`${e}`}const ee=[60,60,24,31,12],re=["second","min","hour","day","month","year"];function er(e,r,t,n=re){e=R.time(e),r=R.time(r),n.length!==re.length&&(n=re);let s=e.getTime()-r.getTime(),o;for(s/=1e3,o=0;o<ee.length&&!(s<ee[o]);o++)s/=ee[o];return`${Math.floor(s)}${t?n[o]:""}`}Object.freeze([W.Again,W.Hard,W.Good,W.Easy]);function rr(e,r){return{due:e?R.time(e):new Date,stability:0,difficulty:0,elapsed_days:0,scheduled_days:0,reps:0,lapses:0,state:Z.New,last_review:void 0}}var tr=(e=>(e.SCHEDULER="Scheduler",e.SEED="Seed",e))(tr||{});const te="offscreen.html";let G=null;const nr=new Ye;async function sr(){const e=await nr.acquire();try{if((await E.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[E.runtime.getURL(te)]})).length>0)return;if(G){console.log("[DB Util] Waiting for existing offscreen document creation..."),await G;return}console.log("[DB Util] Creating offscreen document..."),G=chrome.offscreen.createDocument({url:te,reasons:["DOM_PARSER"],justification:"Provides PGlite database operations."});try{await G,console.log("[DB Util] Offscreen document created successfully.")}catch(t){if(console.error("[DB Util] Error creating offscreen document:",t),(await E.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[E.runtime.getURL(te)]})).length===0)throw new Error(`Offscreen document creation failed: ${t.message}`);console.warn("[DB Util] Offscreen document existed despite creation error/race condition.")}finally{G=null}}finally{e()}}async function ne(e,r){return await sr(),M("dbQuery",{sql:e,params:r||[]})}async function or(e,r=new Date){var g,c;const t=rr(r),n=Z[t.state],s=`
        INSERT INTO flashcards (
            type, front, back, cloze_text, source_url, source_highlight, 
            source_language, target_language, context, tags, 
            due, stability, difficulty, elapsed_days, scheduled_days, 
            reps, lapses, state, last_review
        )
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
        RETURNING *; 
    `,o=[e.type,e.front??null,e.back??null,e.cloze_text??null,e.source_url??null,e.source_highlight??null,e.source_language??null,e.target_language??null,e.context??null,e.tags??null,t.due.toISOString(),t.stability,t.difficulty,t.elapsed_days,t.scheduled_days,t.reps,t.lapses,n,((g=t.last_review)==null?void 0:g.toISOString())??null],l=await ne(s,o);if(!((c=l==null?void 0:l.rows)!=null&&c[0]))throw new Error("Failed to create flashcard");return l.rows[0]}async function ar(e){var s;const r=`
        INSERT INTO chat_messages (role, content, bookmark_id, flashcard_id)
        VALUES ($1, $2, $3, $4)
        RETURNING *;
    `,t=[e.role,e.content??null,e.bookmark_id??null,e.flashcard_id??null],n=await ne(r,t);if(!((s=n==null?void 0:n.rows)!=null&&s[0]))throw new Error("Failed to create chat message");return console.log("[db.ts createChatMessage] Raw DB result row:",n.rows[0]),n.rows[0]}async function ir(e){var $;const{prompt:r,history:t=[],config:n,sendChunk:s}=e,o=n,l=o.chatModel,g=`${o.endpoint.replace(/\/$/,"")}/api/chat`;console.log(`[ollamaProvider] Sending chat request to ${g} with model ${l}`);const c=await fetch(g,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({model:l,messages:[...t,{role:"user",content:r}],stream:!0})});if(!c.ok||!c.body){const v=await c.text().catch(()=>"Failed to read error body");throw new Error(`Ollama API error (${c.status}): ${v}`)}const A=c.body.getReader(),y=new TextDecoder;let w="";for(;;){const{done:v,value:b}=await A.read();if(v)break;w+=y.decode(b,{stream:!0});const S=w.split(`
`);w=S.pop()||"";for(const C of S)if(C.trim()!=="")try{const O=JSON.parse(C);let N=null;($=O.message)!=null&&$.content?N={status:"chunk",content:O.message.content}:O.done&&(N={status:"done",stats:{model:O.model,created_at:O.created_at,total_duration:O.total_duration,load_duration:O.load_duration,prompt_eval_count:O.prompt_eval_count,prompt_eval_duration:O.prompt_eval_duration,eval_count:O.eval_count,eval_duration:O.eval_duration}},console.log("[ollamaProvider] Stream finished.",N.stats)),N&&s(N)}catch(O){console.error("[ollamaProvider] Failed to parse Ollama stream chunk:",C,O)}}w.trim()&&console.warn("[ollamaProvider] Stream ended with unprocessed buffer:",w)}async function lr(e){const{prompt:r,history:t=[],config:n}=e,s=n,o=s.chatModel,m=`${s.endpoint.replace(/\/$/,"")}/api/chat`;console.log(`[ollamaProvider] Sending NON-STREAMING chat request to ${m} with model ${o}`);try{const g=await fetch(m,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({model:o,messages:[...t,{role:"user",content:r}],stream:!1})});if(!g.ok){const A=await g.text().catch(()=>"Failed to read error body");return console.error(`[ollamaProvider] Chat Completion API error (${g.status}): ${A}`),null}const c=await g.json();return!c.message||typeof c.message.content!="string"?(console.error("[ollamaProvider] Invalid response format from Ollama Chat API (non-streaming). 'message.content' not found or not a string.",c),null):(console.log("[ollamaProvider] Received non-streaming response:",c),{message:{role:"assistant",content:c.message.content},usage:{prompt_tokens:c.prompt_eval_count,completion_tokens:c.eval_count}})}catch(g){return console.error("[ollamaProvider] Network or parsing error during chat completion:",g),null}}async function cr(e){const{content:r,config:t}=e,n=t;if(!n.embeddingModel)throw new Error("Ollama configuration missing required embeddingModel.");const s=n.embeddingModel,l=`${n.endpoint.replace(/\/$/,"")}/api/embeddings`;if(console.log(`[ollamaProvider] Requesting embeddings from ${l} with model ${s}`),Array.isArray(r))throw new Error("Ollama embedding currently only supports single string input in this implementation.");const m=await fetch(l,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({model:s,prompt:r})});if(!m.ok){const c=await m.text().catch(()=>"Failed to read error body");throw new Error(`Ollama Embeddings API error (${m.status}): ${c}`)}const g=await m.json();if(!g.embedding||!Array.isArray(g.embedding))throw new Error("Invalid response format from Ollama Embeddings API. 'embedding' array not found.");return{embeddings:[g.embedding]}}const be={providerId:"ollama",streamChat:ir,chatCompletion:lr,getEmbeddings:cr};async function gr(e){var v,b,S;const{prompt:r,history:t=[],config:n,sendChunk:s}=e,o=n,l=o.chatModel,m=o.apiKey,g="https://openrouter.ai/api/v1/chat/completions";console.log(`[openRouterProvider] Sending chat request to ${g} with model ${l}`);const c=await fetch(g,{method:"POST",headers:{Authorization:`Bearer ${m}`,"Content-Type":"application/json"},body:JSON.stringify({model:l,messages:[...t,{role:"user",content:r}],stream:!0})});if(!c.ok||!c.body){const C=await c.text().catch(()=>"Failed to read error body");throw new Error(`OpenRouter API error (${c.status}): ${C}`)}const A=c.body.getReader(),y=new TextDecoder;let w="",$=!1;for(;!$;){const{done:C,value:O}=await A.read();$=C,w+=y.decode(O,{stream:!0});const N=w.split(`
`);w=N.pop()||"";for(const J of N)if(J.startsWith("data: ")){const I=J.substring(6).trim();if(I==="[DONE]"){s({status:"done",stats:{}}),console.log("[openRouterProvider] Stream finished."),$=!0;break}try{const d=(S=(b=(v=JSON.parse(I).choices)==null?void 0:v[0])==null?void 0:b.delta)==null?void 0:S.content;d&&s({status:"chunk",content:d})}catch(u){console.error("[openRouterProvider] Failed to parse stream chunk:",I,u)}}}w.trim()&&console.warn("[openRouterProvider] Stream ended with unprocessed buffer:",w)}const mr={providerId:"openrouter",streamChat:gr};let se=null;async function oe(){var e,r;if(se)return se;console.log("[llmService] Loading user configuration from DB...");try{const t=await ne("SELECT config_json FROM user_configuration WHERE id = 1;");if((r=(e=t==null?void 0:t.rows)==null?void 0:e[0])!=null&&r.config_json){const n=JSON.parse(t.rows[0].config_json);return console.log("[llmService] Loaded config:",n),se=n,n}else return console.warn("[llmService] No configuration found in database."),null}catch(t){return console.error("[llmService] Error loading configuration:",t),null}}async function ur(e){const{prompt:r,history:t,config:n}=e;console.log(`[llmService] Routing chat stream for provider: ${n.provider}`);const s=ae(n);if(!s)throw new Error(`Unsupported provider: ${n.provider}`);if(!s.streamChat)throw new Error(`Provider ${n.provider} does not support streaming chat.`);const o={prompt:r,history:t,config:n,sendChunk:l=>{M("ollamaResponse",l).catch(m=>console.error("Failed to send chunk to UI:",m))}};try{await s.streamChat(o)}catch(l){console.error(`[llmService] Error during streamChat for ${n.provider}:`,l),M("ollamaResponse",{status:"error",error:l instanceof Error?l.message:String(l)}).catch(m=>console.error("Failed to send error chunk to UI:",m))}}function dr(e,r){return`
Generate two types of flashcards from the text below: a concise "Flashcard" (Front/Back) and a "Cloze" deletion card.

Text Selection:
"""
${e}
"""


Instructions:

1.  **Flashcard (Front/Back):**
    *   Front: A short topic or concept (max 8 words).
    *   Back: A concise fact or definition related to the front (max 8 words).
    *   **IMPORTANT:** Do NOT include trailing punctuation. Back should ONLY contain the fact, no filler.

2.  **Cloze Card:**
    *   Create a single sentence using the main idea.
    *   Replace the single most *meaningful* keyword/phrase with {{c1::answer}}.
    *   **AVOID** deleting trivial words (the, is, a) or the obvious main subject.

3.  **Output Format:**
    *   Return ONLY a valid JSON object. No extra text, explanations, or markdown.
    *   Use this EXACT structure:
    \`\`\`json
    {
      "flashcard": { "front": "topic/concept", "back": "concise fact" },
      "cloze": { "text": "Sentence with {{c1::answer}} deletion." }
    }
    \`\`\`

Examples:

--- Example 1 ---
Input Text: "The Eiffel Tower, located in Paris, France, was completed in 1889."
Output JSON:
\`\`\`json
{
  "flashcard": { "front": "Eiffel Tower Location", "back": "Paris, France" },
  "cloze": { "text": "The Eiffel Tower, located in Paris, France, was completed in {{c1::1889}}" }
}
\`\`\`
(Flashcard: Good - concise topic/fact. Cloze: Good - specific detail deleted.)

--- Example 2 ---
Input Text: "Photosynthesis is the process used by plants to convert light energy into chemical energy."
Output JSON:
\`\`\`json
{
  "flashcard": { "front": "Photosynthesis", "back": "Converts light to chemical energy" },
  "cloze": { "text": "Photosynthesis is the process used by plants to convert {{c1::light energy}} into chemical energy" }
}
\`\`\`
(Flashcard: Good - concept/definition. Cloze: Good - key concept deleted.)

--- Example 3 ---
Input Text: "The Wachowskis wrote and directed the Matrix film series."
Output JSON:
\`\`\`json
{
  "flashcard": { "front": "The Matrix Directors", "back": "The Wachowskis" },
  "cloze": { "text": "The {{c1::Wachowskis}} wrote and directed the Matrix film series" }
}
\`\`\`
(Flashcard: Good - specific role. Cloze: Better - deleted the directors instead of the trivial 'Matrix'.)

--- Example 4 (Bad Examples) ---
Input Text: "React is a JavaScript library for building user interfaces."
Bad Flashcard Back: "React is a JS library for UIs." (Trailing period)
Bad Flashcard Back: "It is a library for building UIs" (Exceeds 8 words, filler)
Bad Cloze: "React is a JavaScript library for building {{c1::user interfaces}}" (Okay, but less ideal than deleting 'JavaScript library')
Bad Cloze: "{{c1::React}} is a JavaScript library for building user interfaces." (Trivial deletion of main subject)

Now, generate the flashcards for the provided text selection. Output ONLY the JSON object:
`.trim()}function ae(e){switch(e.provider){case"ollama":return be;case"openrouter":return mr;default:return e.endpoint?(console.warn(`[llmService] Using ollamaProvider for potentially compatible provider: ${e.provider}`),be):(console.error(`[llmService] Unsupported provider found in config: ${e.provider}`),null)}}async function fr(e){var l,m,g,c,A,y;console.log("[llmService] Generating flashcard content for text:",e.substring(0,50)+"...");const r=await oe();if(!r)throw new Error("LLM configuration not found.");const t=ae(r);if(!t)throw new Error(`Unsupported provider: ${r.provider}`);if(!t.streamChat)return console.error(`[llmService] Provider ${r.provider} does not support streaming chat. Cannot generate flashcards.`),null;const n=dr(e);let s="",o=null;console.log("[llmService] Sending flashcard generation prompt via streamChat...");try{if(await new Promise((w,$)=>{const v={prompt:n,config:r,history:[],sendChunk:b=>{b.status==="chunk"&&b.content?s+=b.content:b.status==="error"?(console.error("[llmService flashcard stream] Received error chunk:",b.error),o=b.error||"Unknown streaming error"):(b.status==="done"||b.status==="complete")&&(console.log("[llmService flashcard stream] Stream finished."),w())}};t.streamChat(v).catch($)}),o&&console.error("[llmService] Flashcard stream completed with error:",o),!s)return console.error("[llmService] Flashcard stream completed but accumulated content is empty."),null;console.log("[llmService] Received accumulated stream response for parsing:",s);try{const w=s.match(/```json\s*([\s\S]*?)\s*```|({[\s\S]*})/);if(!w||!w[1]&&!w[2]){console.error("[llmService] Could not find JSON block in the accumulated stream response.");try{const b=JSON.parse(s.trim());return(l=b.flashcard)!=null&&l.front&&((m=b.flashcard)!=null&&m.back)&&((g=b.cloze)!=null&&g.text)?(console.log("[llmService] Successfully parsed flashcard JSON from raw stream response (fallback)."),b):(console.error("[llmService] Parsed fallback stream JSON lacks expected structure:",b),null)}catch(b){return console.error("[llmService] Failed to parse JSON directly from accumulated stream (fallback failed):",b),null}}const $=w[1]||w[2],v=JSON.parse($.trim());return(c=v.flashcard)!=null&&c.front&&((A=v.flashcard)!=null&&A.back)&&((y=v.cloze)!=null&&y.text)?(console.log("[llmService] Successfully parsed flashcard JSON from accumulated stream response."),v):(console.error("[llmService] Parsed stream JSON lacks expected structure (flashcard/cloze):",v),null)}catch(w){return console.error("[llmService] Error parsing JSON from accumulated stream response:",w),console.error("--- Accumulated Raw Content ---"),console.error(s),console.error("--- End Accumulated Raw Content ---"),null}}catch(w){return console.error("[llmService] Error during flashcard generation stream setup or promise handling:",w),null}}async function Ar(e,r){var o,l;console.log(`[llmService] Translating text to ${r}: "${e.substring(0,50)}..."`);const t=await oe();if(!t)return console.error("[llmService translateText] Cannot translate: LLM config not loaded."),null;const n=ae(t);if(!(n!=null&&n.chatCompletion))return console.error(`[llmService translateText] Provider ${t.provider} does not support 'chatCompletion'.`),null;const s=`Translate the following text accurately to ${r}. Output ONLY the translated text, nothing else:

Text to translate:
"""
${e}
"""

Translated text:`;console.log(`[llmService translateText] Sending translation prompt to ${t.provider}...`);try{const m=await n.chatCompletion({prompt:s,config:t,history:[]}),g=(l=(o=m==null?void 0:m.message)==null?void 0:o.content)==null?void 0:l.trim();return g?(console.log("[llmService translateText] Received translation:",g),g):(console.error("[llmService translateText] LLM response was empty or invalid."),null)}catch(m){return console.error("[llmService translateText] Error during translation LLM call:",m),null}}function hr(e){return e==null||typeof e=="function"?{main:e}:e}console.log("Background script loaded.");const ie="/offscreen.html";async function pr(){const e=E.runtime.getURL(ie);return(await E.runtime.getContexts({contextTypes:["OFFSCREEN_DOCUMENT"],documentUrls:[e]})).length>0}async function ye(){if(await pr())console.log("[Background] Offscreen document already exists.");else{console.log("[Background] Creating offscreen document..."),console.log(`[Background] Using offscreen path for creation: ${ie}`);try{await E.offscreen.createDocument({url:ie,reasons:[E.offscreen.Reason.LOCAL_STORAGE],justification:"Database operations using PGlite"}),console.log("[Background] Offscreen document creation requested."),await new Promise(e=>setTimeout(e,200))}catch(e){throw console.error("[Background] Error creating offscreen document:",e),e}}}console.log("Background script setup starting...");const xr=hr(()=>{console.log("WXT Background defined (using wxt/utils/define-background)"),U("clipPage",async e=>{if(console.log("Background: Received clipPage message",e.data),!e.data){console.error("Background: clipPage message received without data.");return}const{title:r,url:t}=e.data,n="INSERT INTO clips (title, url) VALUES (?, ?);",s=[r,t];console.log("Background: Sending dbExec message to offscreen for clipping...");try{const o=await M("dbExec",{sql:n,params:s});console.log("Background: Offscreen dbExec response:",o),console.log(`Background: Successfully clipped ${t}`),E.notifications.create(`clip-success-${Date.now()}`,{type:"basic",iconUrl:E.runtime.getURL("/icon/128.png"),title:"Bookmark Saved",message:`Saved: ${r}`,priority:0})}catch(o){console.error("Background: Error executing clip via offscreen:",o),E.notifications.create(`clip-error-${Date.now()}`,{type:"basic",iconUrl:E.runtime.getURL("/icon/128.png"),title:"Bookmark Saving Failed",message:`Could not save ${r}. Error: ${o instanceof Error?o.message:String(o)}`,priority:1})}}),U("getOllamaModels",async e=>{if(console.log("[Background] Received getOllamaModels message",e.data),!e.data||!e.data.endpoint){console.error("[Background] getOllamaModels message missing endpoint."),M("getOllamaModelsResult",{endpoint:void 0,success:!1,error:"No endpoint received"}).catch(s=>console.error("[Background] Failed to send error:",s));return}const{endpoint:r}=e.data,t="getOllamaModelsResult",n=`${r}/api/tags`;console.log(`[Background] Attempting to fetch models from: ${n}`);try{const o=await fetch(n,{method:"GET",headers:{Accept:"application/json"}});if(!o.ok){let g="[Could not read error body]";try{g=await o.text()}catch{}throw console.error(`[Background] Fetch failed: Status ${o.status}. Body:`,g),new Error(`Failed to fetch Ollama models: ${o.status} ${o.statusText}`)}const l=await o.json(),m=Array.isArray(l==null?void 0:l.models)?l.models.map(g=>({id:g.name,name:g.name})):[];console.log("[Background] Successfully fetched Ollama models:",m),M(t,{endpoint:r,success:!0,models:m}).catch(g=>console.error(`[Background] Failed to send ${t} success:`,g))}catch(s){console.error("[Background] Error during fetch operation:",s);let o=s instanceof Error?s.message:"Unknown error fetching models.";o.includes("Failed to fetch")&&(o+=". Ensure Ollama is running and reachable, and check extension host permissions."),M(t,{endpoint:r,success:!1,error:o}).catch(l=>console.error(`[Background] Failed to send ${t} error:`,l))}}),U("ollamaChatRequest",async e=>{if(console.log("Background: Received ollamaChatRequest",e.data),!e.data||!e.data.prompt){console.error("Background: ollamaChatRequest message missing prompt.");return}const{prompt:r,history:t}=e.data,n=await oe();if(!n){console.error("Background: Cannot process chat request, user config not found."),M("ollamaResponse",{model:"unknown",created_at:new Date().toISOString(),status:"error",error:"LLM configuration not found. Please set it up in the settings."}).catch(s=>console.error("Failed to send config error message:",s));return}try{await ur({prompt:r,history:t||[],config:n}),console.log("Background: streamChatResponse processing initiated.")}catch(s){console.error("[Background] Error invoking streamChatResponse:",s),M("ollamaResponse",{model:n.chatModel||"unknown",created_at:new Date().toISOString(),status:"error",error:s instanceof Error?s.message:"Error during streaming"}).catch(o=>console.error("Failed to send stream error message:",o))}}),U("generateFlashcardContent",async e=>{console.log("[Background] Received generateFlashcardContent message",e.data);const r="flashcardGenerationResult";if(!e.data||!e.data.text){console.error("[Background] No text provided for flashcard generation."),M(r,{data:null,error:"No text provided"}).catch(n=>console.error("Failed to send error result:",n));return}const{text:t}=e.data;try{const n=await fr(t);console.log("[Background] Received result from llmService:",n),await new Promise(s=>setTimeout(s,50)),console.log("[Background] Attempting to send flashcard result after delay..."),M(r,{data:n,error:void 0}).catch(s=>console.error("Failed to send flashcard result:",s))}catch(n){console.error("[Background] Error during flashcard generation:",n),M(r,{data:null,error:n.message||"Unknown error during generation"}).catch(s=>console.error("Failed to send error result:",s))}}),U("getPageInfo",async()=>{console.log("[Background] Received getPageInfo request.");try{const r=(await E.tabs.query({active:!0,currentWindow:!0}))[0];return r&&r.url&&r.title?(console.log("[Background] Sending page info:",{title:r.title,url:r.url}),{title:r.title,url:r.url}):(console.warn("[Background] Could not get active tab info."),null)}catch(e){return console.error("[Background] Error getting page info:",e),null}}),U("getSelectedText",async()=>{var e,r,t;console.log("[Background] Received getSelectedText request (from UI).");try{const s=(await E.tabs.query({active:!0,currentWindow:!0}))[0];if(!s||!s.id)return console.warn("[Background] Could not get active tab ID for script injection."),null;const o=s.id;let l=!0;try{const g=await E.tabs.sendMessage(o,{type:"ping"});g&&g.pong&&(l=!1)}catch{console.log("[Background] Ping failed: Content script likely not injected or inaccessible.")}if(l){console.log(`[Background] Injecting content script into tab ${o}...`);try{await E.scripting.executeScript({target:{tabId:o},files:["content-scripts/content.js"]}),console.log("[Background] Content script injected."),await new Promise(g=>setTimeout(g,100))}catch(g){return console.error(`[Background] Failed to inject content script into tab ${o}:`,g),null}}console.log(`[Background] Sending _requestSelectionFromContentScript message to tab ${o}...`);const m=await M("_requestSelectionFromContentScript",void 0,{tabId:o});return console.log("[Background] Received selection from content script via sendMessage:",m),m&&typeof m.text=="string"?{text:m.text}:null}catch(n){return console.error("[Background] Error in getSelectedText handler:",n),(e=n.message)!=null&&e.includes("Could not establish connection")?console.warn("[Background] Connection error likely means the content script wasn't ready or page is restricted."):(r=n.message)!=null&&r.includes("No matching message handler")?console.warn("[Background] 'No matching message handler' likely means the content script is not injected or listening correctly for _requestSelectionFromContentScript."):(t=n.message)!=null&&t.includes("[messaging]")&&console.warn("[Background] Messaging format error during getSelectedText. Check ProtocolMap and listeners.",n),null}}),U("translateText",async e=>{if(console.log("[Background] Received translateText request",e.data),!e.data||!e.data.text||!e.data.targetLang)throw console.error("Background: Missing text or target language for translation."),new Error("Missing text or target language for translation.");const{text:r,targetLang:t}=e.data;try{const n=await Ar(r,t);if(n===null)throw console.error("[Background] Translation service returned null."),new Error("Translation failed or returned null.");return console.log("[Background] Translation successful:",n),n}catch(n){throw console.error("[Background] Translation error:",n),new Error(n.message||"Translation failed")}}),U("saveFlashcardAndNotify",async e=>{if(console.log("[Background] Received saveFlashcardAndNotify request:",e.data),!e.data||!e.data.cardData)return console.error("Background: saveFlashcardAndNotify message received without cardData."),E.notifications.create(`flashcard-save-error-${Date.now()}`,{type:"basic",iconUrl:E.runtime.getURL("/icon/128.png"),title:"Flashcard Save Failed",message:"Error: Missing flashcard data.",priority:1}),null;const{cardData:r}=e.data;try{const t=await or(r);return console.log("[Background] Flashcard created in DB:",t),await ar({role:"flashcard",flashcard_id:t.id}),console.log(`[Background] Associated chat message created for flashcard ID: ${t.id}`),E.notifications.create(`flashcard-save-success-${Date.now()}`,{type:"basic",iconUrl:E.runtime.getURL("/icon/128.png"),title:"Flashcard Saved",message:`Saved: ${r.front||"Cloze Card"}`,priority:0}),t}catch(t){return console.error("[Background] Error saving flashcard or creating chat message:",t),E.notifications.create(`flashcard-save-error-${Date.now()}`,{type:"basic",iconUrl:E.runtime.getURL("/icon/128.png"),title:"Flashcard Save Failed",message:`Error: ${t.message||"Unknown error"}`,priority:1}),null}}),U("saveConfiguration",async e=>{if(console.log("[Background] Received saveConfiguration request..."),!e.data||!e.data.configJson)throw console.error("[Background] saveConfiguration message received without configJson."),new Error("No configuration JSON string received.");try{const r=JSON.parse(e.data.configJson);console.log("[Background] Parsed configuration object:",r),await E.storage.local.set({userConfig:r}),console.log("[Background] User configuration saved successfully.")}catch(r){throw console.error("[Background] Error saving user configuration:",r),new Error(r.message||"Unknown error saving config")}}),E.runtime.onInstalled.addListener(async e=>{if(console.log("Extension installed:",e),e.reason==="install"){console.log("Performing first-time setup..."),await ye().catch(t=>{console.error("[Background] Initial setupOffscreenDocument failed on install:",t)});const r=E.runtime.getURL("onboarding.html");await E.tabs.create({url:r,active:!0}),console.log(`Opened onboarding page: ${r}`)}else e.reason==="update"&&console.log(`[Background] Updated from ${e.previousVersion} to ${E.runtime.getManifest().version}`)}),E.runtime.onStartup.addListener(async()=>{console.log("[Background] Browser startup detected. Setting up offscreen document...");try{await ye(),console.log("[Background] Offscreen document setup complete on startup.")}catch(e){console.error("[Background] setupOffscreenDocument failed on startup:",e)}}),console.log("Background script setup complete.")});function vr(){}(ke=(ve=globalThis.browser)==null?void 0:ve.runtime)!=null&&ke.id?globalThis.browser:globalThis.chrome;function Y(e,...r){}const wr={debug:(...e)=>Y(console.debug,...e),log:(...e)=>Y(console.log,...e),warn:(...e)=>Y(console.warn,...e),error:(...e)=>Y(console.error,...e)};let le;try{le=xr.main(),le instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(e){throw wr.error("The background crashed on startup!"),e}return le}();
background;
